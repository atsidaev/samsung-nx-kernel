/*
 * hr-timer.c  --  DRIME4 High Resolution Timer driver
 *
 * Copyright (c) 2011 Samsung Electronics Co., Ltd.
 *		http://www.samsung.com/
 *
 * Author: Chanwoo Choi <cw00.choi@samsung.com>
 *
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <linux/sched.h>
#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/irq.h>
#include <linux/clockchips.h>

#include <asm/io.h>
#include <asm/mach/time.h>
#include <asm/sched_clock.h>

#include <mach/map.h>
#include <mach/regs-timer.h>

#define TIMER_CLOCK_HZ		133333333

enum DRIME4_TIMER_NUM {
	DRIME4_TIMER0,
	DRIME4_TIMER1,
	DRIME4_TIMER2,
	DRIME4_TIMER3,
	DRIME4_TIMER4,
	DRIME4_TIMER_COUNT,
};

static void __iomem *clkevt_base = DRIME4_TIMER_BASE(DRIME4_TIMER2);
static void __iomem *clksrc_base = DRIME4_TIMER_BASE(DRIME4_TIMER1);

static unsigned long clk_rate;
static unsigned long clk_scale;
static unsigned long clk_cnt_per_tick;
static void drime4_timer_resume(void);

static void drime4_timer_start(void __iomem *base, unsigned int ctrl,
		unsigned long cycles)
{
	unsigned int reg = __raw_readl(clkevt_base + TIMER_CTR_OFFSET);
	__raw_writel(reg & ~TIMER_CTR_ENABLE_TIMER, base + TIMER_CTR_OFFSET);
	__raw_writel(cycles, base + TIMER_LDR_OFFSET);
	__raw_writel(reg | TIMER_CTR_ENABLE_TIMER | ctrl,
			base + TIMER_CTR_OFFSET);
}

/*
 * Clock event device handling
 */
static int drime4_tick_set_next_event(unsigned long cycles,
					struct clock_event_device *evt)
{
	drime4_timer_start(clkevt_base, 0, cycles);
	return 0;
}

static void drime4_tick_set_mode(enum clock_event_mode mode,
				struct clock_event_device *evt)
{
	switch (mode) {
	case CLOCK_EVT_MODE_PERIODIC:
		drime4_timer_start(clkevt_base, TIMER_CTR_PERIODIC_MODE
					| TIMER_CTR_ENABLE_TIMER_IRQ,
					clk_cnt_per_tick);
		break;
	case CLOCK_EVT_MODE_ONESHOT:
	case CLOCK_EVT_MODE_UNUSED:
	case CLOCK_EVT_MODE_SHUTDOWN:
	case CLOCK_EVT_MODE_RESUME:
		drime4_timer_resume();
		break;
	}
}

static void drime4_timer_resume(void)
{
	drime4_timer_start(clkevt_base, TIMER_CTR_PERIODIC_MODE
			| TIMER_CTR_ENABLE_TIMER_IRQ,
			clk_cnt_per_tick);
//	drime4_timer_start(clksrc_base, TIMER_CTR_PERIODIC_MODE, 0xffff);
}

static struct clock_event_device timer_tick_dev = {
	.name		= "CLOCK_EVENT_DEV_TIMER2",
	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
	.rating		= 400,
	.set_next_event	= drime4_tick_set_next_event,
	.set_mode	= drime4_tick_set_mode,
};

static irqreturn_t drime4_timer_tick_isr(int irq, void *dev_id)
{
	struct clock_event_device *evt = dev_id;

	__raw_writew(0, DRIME4_TIMER_BASE(DRIME4_TIMER2) + TIMER_ISR_OFFSET);
	evt->event_handler(evt);

	return IRQ_HANDLED;
}

static struct irqaction timer_tick_irq = {
	.name		= "CLOCK_EVENT_DEV_TIMER2",
	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
	.handler	= drime4_timer_tick_isr,
	.dev_id		= &timer_tick_dev,
};

static void __init drime4_clockevent_init(void)
{
	clockevents_calc_mult_shift(&timer_tick_dev, clk_rate / clk_scale, 5);

	timer_tick_dev.max_delta_ns =
		clockevent_delta2ns(0xffff, &timer_tick_dev);
	timer_tick_dev.min_delta_ns =
		clockevent_delta2ns(0xf, &timer_tick_dev);

	timer_tick_dev.cpumask = cpumask_of(0);
	clockevents_register_device(&timer_tick_dev);

	setup_irq(IRQ_TIMER2, &timer_tick_irq);
}

u32 notrace drime4_read_sched_clock(void)
{
	u16 cyc;
	cyc = ~(__raw_readl(clksrc_base + TIMER_LDR_OFFSET) & 0xffff);
	return cyc;
}

static void __init drime4_clocksource_init(void)
{
	setup_sched_clock(drime4_read_sched_clock, 16,
			clk_rate / clk_scale);

	drime4_timer_start(clksrc_base, TIMER_CTR_PERIODIC_MODE, 0xffff);

	if (clocksource_mmio_init(clksrc_base + TIMER_LDR_OFFSET,
		"drime4_clocksource_timer",
		clk_rate / clk_scale, 200, 16, clocksource_mmio_readl_down))
		panic("drime4_clocksource_timer: can't register clocksourcn");
}

static void __init drime4_timer_init(void)
{
	int i;

	/* Initialize variables about clock */
	clk_rate = TIMER_CLOCK_HZ;		/* Clock - 133MHz*/
	clk_scale = clk_rate / 1000000;		/* Divider- 133 */
	clk_cnt_per_tick = (TIMER_CLOCK_HZ / clk_scale) / HZ;
	if (clk_cnt_per_tick > 65535)
		panic("could not set ldr value higher than 65535\n");

	/* Initialize timer[0-4] */
	for (i = 0 ; i < DRIME4_TIMER_COUNT ; i++) {
		__raw_writew(0x00, DRIME4_TIMER_BASE(i) + TIMER_CTR_OFFSET);

		/* PCLK = 133,333,333 / PRESCALER(=133) => 100,025 (1 Mhz)
		 * - If LDR value is 5012, timer irq is generated by 5ms,
		 *   because the range of LDR register is below 65535.
		 * - If HZ is 200, timer irq is generated by 5ms.(period = 1/HZ)
		 */

		/* TIMER_PRESCALER (PSR) */
		__raw_writew(clk_scale - 1,
			DRIME4_TIMER_BASE(i) + TIMER_PSR_OFFSET);
	}

	drime4_clocksource_init();
	drime4_clockevent_init();
}

struct sys_timer drime4_timer = {
	.init		= drime4_timer_init,
};
